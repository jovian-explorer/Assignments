# -*- coding: utf-8 -*-
"""assignment 1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1d1EA9PzOLLOpJ4rBQ865ftdFJi1xwlm-

##**2.1 Problem 1**
Encode the following algorithm and run it to determine the smallest positive number that can be *represented* on the computer you are using:

input s <--- 1.0

for k=1,2,3,...,100 do

s <--- 0.5*s

t <--- s + 1.0

if t <= 1.0 then

s <--- 2.0*s

output k-1, s

stop

endif

end

Do this for both single precision and double precision 
floating point numbers.
"""

import numpy as np

s=1.00

#range gives you a range of numbers
#range(inclusive_start, exclusive_end, step).
for k in range(1,101,1): 

    s= np.float32(0.5*s)
    
    t= np.float32(s + 1.00)
    

    if t <= 1.00:
    
      s = 2.0*s
      break
# Gives Single Precision output      
print ("Single Precision:", k-1,s)

import numpy as np

s=1.00

# range gives you a range of numbers.
# range(inclusive_start, exclusive_end, step).
for k in range(1,101,1):  

    s= np.float64(0.5*s)
    
    t= np.float64(s + 1.00)
    
    
    if t <= 1.00:
    
       s = 2.0*s
       break
# Gives Double Precision output
print ("Double Precision:", k-1,s)

"""## **2.2 Problem 2**
Evaluate the expression
$$
y =  y = \sqrt{(x^2 + 1.0)} - 1.0
$$
in two ways:
$$
y = \sqrt{(x^2 + 1.0)}- 1.0 
$$
and 
$$
y = \frac {x^2}{[\sqrt{(x^2 + 1.0)} + 1.0]}
$$
for small values of x, x=0.1, 0.01 and 0.001. 

Determine the fractional error in both the methods of performing the subtraction. Which method is superior and why?
"""

# Importing the numpy libraries
# Importing the numpy libraries
import numpy as np                                             
 
 # Setting x and y as lists containing values for which we will perform the two methods
x=[0.1,0.01,0.001]                                            
y=[0.004987562112089027021926491275957619,0.000049998750062496094023416993798697,0.000000499999875000062499960937527343]                                              
 
print('Value of x    ',"  "," Value of Fn 1","          ", " Value of Fn 2 ","         ","Fractional Error 1","","Percentage Error 1","" , "Fractional Error 2","","Percentage Error 2","","Difference ")
print('_________________________________________________________________________________________________________________________________________________________')
 
for z in x:
  for q in y:
 
# Searches for a given element from the list and returns the lowest index where the element appears 
    g=x.index(z)                                                                                 
    q=y.index(q)                                               
 
    
    # Method 1 to solve for y using the values given for x
    y1 = np.float128((np.sqrt((x[g]**2) + 1))- 1)
    # Method 2 to solve for y using the values given for x              
    y2 = np.float128(x[g]**2 / ((np.sqrt(x[g]**2 + 1.0))+1.0)) 
    
    # To calculate the fractional error for method 1
    Frac_error1 = abs((y[q]-y1)/y[q])                          
    # To calculate the percentage error for method 1
    Per_error1 = Frac_error1*100                               
    
    # To calculate the fractional error for method 2
    Frac_error2 = abs((y[q]-y2)/y[q])  
    # To calculate the percentage error for method 2                        
    Per_error2 = Frac_error2*100 
  
    #To test which method is superior
    #I subtracted one error from other to check which error is greater
    #The greater error will give a negative value when subtracted from a smaller value and vice versa.
    difference= Per_error1- Per_error2                 
  
  print(' %.3f     '%x[g],'  %.17f     '%y1,'    %.17f   '%y2,'     %e  '%Frac_error1,'       %e'%Per_error1,'     %e      '%Frac_error2,'  %e'%Per_error2,'   %e'%difference)
    # To give a blank row after each row. No use, just to improve the aesthetics of the table
  print('')

"""## **2.3 Problem 3**
It is desired to calculate all integral powers of the number
$$
x =  \sqrt{(5.0)} - 1.0)/2.0
$$
 It turns out that the integral powers of x satisfy a simple recursive relation
$$
  x^{n+1} = x^{n-1} - x^n
$$
  Show that the above recurrence relation is unstable by calculating $$x^{16}, x^{30}, x^{40} and x^{50} $$ from the recurrence relation and comparing with the actual values.
"""

import numpy as np

#defining the value of x 
x  = (np.sqrt(5.0)-1.0)/2.0

#defining an array of powers of x for which we have to check the function
y = np.array([16,30,40,50])


print('Power of x',"  ","LHS= Value from f1","    ", "RHS= Value from f2 ","  ", "Difference")
print('_______________________________________________________________________________')

#defining functions f1 and f2 which take values of power from y
for i in range(0,4):

  def f1(a,b):
      p = np.float64(a**b)
      return p
  def f2(a,b):
      q = np.float64(a**(b-2) - (a**(b-1)))
      return q
      
  #defining the two sides of the equation as LHS and RHS    
  LHS=f1(x,y[i])
  RHS=f2(x,y[i])
  #calculating the difference betwwen the values of LHS and RHS  
  diff= np.float64(abs(f1(x,y[i])-f2(x,y[i])))

  print('    %d       '%y[i],'   %e  '%LHS,'        %e'%RHS,'       %e      '%diff)
  print('')

"""## **2.4 Problem 4**
The recurrence relation
$$
\hspace{1cm}y_{n+1} = e - (n + 1)y_n 
$$
(where e is the base of natural logarithm) can be obtained from integration by parts to the integral 
$$
y_n =  \int_{0}^{1}x^ne^x\,dx 
$$
Show that the above recurrence relation is unstable by calculating $$y_{15}$$ and $$y_{20}$$from the recurrence relation. 
"""

from scipy.integrate import quad
import numpy as np

#defining the recurrence function
def R(N,n):
    return (np.e - (n+1)*N)

#defining the function to be integrated
def f(x,n):
    return (x**n) * np.exp(x) 
#defining the integration function with its limits
def I(n):
    return quad(f, 0, 1, args=n)

n=np.array([15,20])

# creating a list of calculated values using recurrence relation 
N = np.float64(I(1)[0])
rec = [0.0,np.float64(N)]
print("Y_n","    ","Value from recurrence relation")
for m in range(1,22,1):
    N = np.float64(R(N,m))
    rec.append(N)
    #all values calculated using recurrence relation from y_2 to y_22
    print("y_%d "%(m+1),'        ',N)

print('')

print('Value of n','  ','Using numerical integration','  ','Using recurrence relation','    ','Fractional Error','       ','Estimated error')
print('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~')
# comparing both methods for functions given in question 
for k in range(len(n)):
    print('  ',n[k],'           ',I(n[k])[0],'         ',rec[n[k]],'     ',(abs(I(n[k])[0] - rec[n[k]])/I(n[k])[0]),'    ',I(n[k])[1])
    print('')

"""## **2.5 Problem 5**
Compute the dot product of the following two vectors
$$
x = [2.718281823, -3.141592654, 1.414213562, 0.5772156649, 0.3010299957]
$$
and
$$
y = [1486.2497, 878366.9879, -22.37492, 4773714.647, 0.000185049]
$$

Compute the summation in four ways:

1. forward order summation $$\{x_iy_i\}$$ for i = 1,n.

2. reverse order summation $$\{x_iy_i\}$$ for i = n,1.

3. largest to smallest order (add positive numbers in order from largest to smallest, then add negative numbers in order from smallest to largest and then add the two partial sums).

4. smallest to largest order (reverse order of adding in the previous method).


Use both single and double precision for a total of eight answers. Compare the results with the correct value $$ 1.006571 x 10^{-9}$$

###Code for forward order summation-
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np

#defining the two vectors
x = [2.718281823, -3.141592654, 1.414213562, 0.5772156649, 0.3010299957]
y = [1486.2497, 878366.9879, -22.37492, 4773714.647, 0.000185049]

#given correct value for dot product
correct_val = 1.006571 * 10**(-9)
#defining empty lists to store the values
list1 = []
list2 = []

dot_32 = 0
dot_64 = 0
#calculation of products
#prod_32 is for single precision
#prod_64 for double precision
for i in range(len(x)):
   
    prod_32 = np.float32(x[i]*y[i])
    list1.append(prod_32)

    prod_64 = np.float64(x[i]*y[i])
    list2.append(prod_64)

#summation of dot products of the vectors with single and double precision methods
#dot_32 is for single precision
#dot_64 for double precision
for i in range(len(list1)):
  dot_32 = dot_32 +list1[i]
  dot_64 = dot_64 +list2[i]
#calculation of error compared to correct value
#e32 is for single precision
#e64 for double precision
e32 = (abs(correct_val - dot_32)/correct_val)*100
e64 = (abs(correct_val - dot_64)/correct_val)*100

#getting the output for forward summation
print('''Dot Product in Forward order:
-----------------------------
For Single Precision: {}                                             = {}
For Double Precision: {}  = {}

# % Error in Single precision method = {}
# % Error in Double precision method = {}
'''.format(list1, dot_32, list2, dot_64, e32, e64))

"""###Code for reverse order summation-"""

# Commented out IPython magic to ensure Python compatibility.
list1.clear()
list2.clear()

dot_32 = 0
dot_64 = 0

#calculation of products
#prod_32 is for single precision
#prod_64 for double precision
for i in range(0, len(x)):
  j = (len(x) - 1) - i
   
  prod_32 = np.float32(x[j] * y[j])
  list1.append(prod_32)

  prod_64 = np.float64(x[j]*y[j])
  list2.append(prod_64)
#summation of dot products of the vectors with single and double precision methods
for i in range(0, len(x)):
  j = (len(x) - 1) - i
#dot_32 is for single precision
#dot_64 for double precision
  dot_32 = dot_32 +list1[j]
  dot_64 = dot_64 +list2[j]
#calculation of error compared to correct value
#e32 is for single precision
#e64 for double precision
e32 = (abs(correct_val - dot_32)/correct_val)*100
e64 = (abs(correct_val - dot_64)/correct_val)*100


#getting the output 
print('''Dot Product in Reverse order:
-----------------------------
For Single Precision: {}                                             = {}
For Double Precision: {}  = {}

# % Error in Single precision method = {}
# % Error in Double precision method = {}
'''.format(list1, dot_32, list2, dot_64, e32, e64))

"""###Code for largest to smallest order(add positive numbers in order from largest to smallest, then add negative numbers in order from smallest to largest and then add the two partial sums)."""

# Commented out IPython magic to ensure Python compatibility.
list1.sort(reverse=True)
list2.sort(reverse=True)

pos_list1 = []
neg_list1 = []

pos_list2 = []
neg_list2 = []
#pspos_32 means partial sum of positive terms for single precision
#psneg_32 means partial sum of negative terms for single precision
#pspos_64 means partial sum of positive terms for double precision
#psneg_64 means partial sum of negative terms for double precision
pspos_32=0
psneg_32=0
pspos_64=0
psneg_64=0

dot_32 = 0
dot_64 = 0
#summation of dot products of the vectors with single precision
for i in range(0, len(list1)):
  if list1[i] > 0:
    pos_list1.append(list1[i])
    pspos_32 = pspos_32 + list1[i]
  else:
    neg_list1.append(list1[i])
    psneg_32 = psneg_32 + list1[i]
#summation of dot products of the vectors with double precision
for i in range(0, len(list2)):
  if list2[i] > 0:
    pos_list2.append(list2[i])
    pspos_64 = pspos_64 + list2[i]
  else:
    neg_list2.append(list2[i])
    psneg_64 = psneg_64 + list2[i]
#final value of dot products of the vectors with single and double precision methods
dot_32 = pspos_32 + psneg_32
dot_64 = pspos_64 + psneg_64
#calculation of error compared to correct value
#e32 is for single precision
#e64 for double precision
e32 = (abs(correct_val - dot_32)/correct_val)*100
e64 = (abs(correct_val - dot_64)/correct_val)*100
#getting the output 
print('''Dot Product in Largest to smallest order:
-----------------------------------------
For Single Precision:
---------------------
    List of Positive terms: {}    = {}
    List of Negative terms: {}               = {}

    Dot Product = {}
#     % Error= {}

For Double Precision:
---------------------
    List of Positive terms: {} = {}
    List of Negative terms: {}                     = {}

    Dot Product = {}
#     % Error= {}
'''.format(pos_list1,pspos_32, neg_list1,psneg_32,dot_32, e32, pos_list2, pspos_64, neg_list2, psneg_64, dot_64, e64))

"""###Code for smallest to largest order (reverse order of adding in the previous method).

"""

# Commented out IPython magic to ensure Python compatibility.
list1.sort(reverse=False)
list2.sort(reverse=False)

pos_list1 = []
neg_list1 = []

pos_list2 = []
neg_list2 = []
#pspos_32 means partial sum of positive terms for single precision
#psneg_32 means partial sum of negative terms for single precision
#pspos_64 means partial sum of positive terms for double precision
#psneg_64 means partial sum of negative terms for double precision
pspos_32=0
psneg_32=0
pspos_64=0
psneg_64=0

dot_32 = 0
dot_64 = 0
#summation of dot products of the vectors with single precision
for i in range(0, len(list1)):
  if list1[i] > 0:
    pos_list1.append(list1[i])
    pspos_32 = pspos_32 + list1[i]
  else:
    neg_list1.append(list1[i])
    psneg_32 = psneg_32 + list1[i]
#summation of dot products of the vectors with double precision
for i in range(0, len(list2)):
  if list2[i] > 0:
    pos_list2.append(list2[i])
    pspos_64 = pspos_64 + list2[i]
  else:
    neg_list2.append(list2[i])
    psneg_64 = psneg_64 + list2[i]
#final value of dot products of the vectors with single and double precision methods
dot_32 = pspos_32 + psneg_32
dot_64 = pspos_64 + psneg_64
#calculation of error compared to correct value
#e32 is for single precision
#e64 for double precision
e32 = (abs(correct_val - dot_32)/correct_val)*100
e64 = (abs(correct_val - dot_64)/correct_val)*100
#getting the output 
print('''Dot Product in Smallest to largest order:
-----------------------------------------
For Single Precision:
---------------------
    List of Positive terms: {}    = {}
    List of Negative terms: {}               = {}

    Dot Product = {}
#     % Error = {}

For Double Precision:
---------------------
    List of Positive terms: {} = {}
    List of Negative terms: {}                     = {}

    Dot Product = {}
#     % Error= {}
'''.format(pos_list1,pspos_32, neg_list1,psneg_32,dot_32, e32, pos_list2, pspos_64, neg_list2, psneg_64, dot_64, e64))